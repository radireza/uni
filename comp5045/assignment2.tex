\documentstyle[11pt]{article}

\author{Nic Hollingum - 308193415}
\title{Computational Geometry - Assignment 2}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\begin{document}
\maketitle

\section {Multi-Range-Query}
From lectures we learnt that range-queries on 2d points and rectangles could be done in $O(\log n + k)$ time with $O(n \log n)$ pre-processing and $O(n)$ space.
In this modified version we must determine all points lying outside all n rectangles.
As it turns out this imposes little extra overhead, given the pre-sorting time.

Sort the points ($O(n \log n)$) and add them to a range-tree ($O(n \log n)$), note that this must only happen once for all range queries.
Next, carry out the query for one of the n rectangles, reporting all points inside the range ($O(\log n + k)$).
Simply repeat this for each rectangle.
For now we will assume this takes $O(n \log n + nk)$ time.
We maintain a list of points ``so far outside all rectangles'' which begins full, and we remove the k reported points at each iteration.
Using a balanced binary tree of points this requires at most n deletions each in $\log n$ time, hence $O(n \log n)$

This procedure reports all points lying inside a range for all ranges, and removes those points from its result.
It therefore correctly reports only those points not inside any range.

From the above description we have presumed the operation is asymptotically dominated by the $O(n \log n + nk)$ operation.
However note that the rectangles are non-overlapping.
This means that over all iterations, each point may only lie inside one rectangle and hence only be reported once.
Then the worst case for this operation is actually $O(n \log n + n)$ or $O(n \log n)$.
Reporting all poinnts outside the rectangles can take at most $O(n)$ time if all points are reported, and so is dominated by other components.
Therefore the entire operation is asymptotically bounded by its $O(n \log n)$ components (sorting, all range queries, removing reported points from result).

\section {Competing Trees}
This tradeoff must be decided based on the kinds of range-searches being performed, and the limitations of the system.
Trivially if we cannot spare the space, then the kd-Trees ($O(n)$ space) is the only option.
However, provided we can afford the extra $O(n\log^{d-1}n)$ space for the Range tree then we must choose based on the tradeoff between pre-processing and query-time.

The query times are $O(n^{1-\frac{1}{d}} + k)$ for kd-Trees and $O(\log^{d-1}n+k)$ for range-trees.
This shows the significant advantage of rnage-trees for query time, and would be preferable always given enough points and queries.
Both algorithms have (reasonably) linear-logarithmic complexity for pre-processing.
This, added to the fact that we are more concerned with query-time than pre-processing time (with fewer than $\log n$ queries, it is better to use naive search with no pre-processing overhead) lead to the chouce of range-trees wherever permitting.

\section {2 Point Visibility}
We first note that we are given a convex polygon.
This has a special property that a point infinately distant from the polygon will be able to 'see' all edge-points along ``half'' the boundary.
Note this is not hald the number of boundary points, but rather that between it and another point infinitely distant on the opposite side, all points are visible.
This is because of the convexity, in order for this property to not hold for all infinitely distant points, a part of the polygon must somehow ``shadow'' other points.
In other words, the line cast from the infinite point must enter the polygon, traverse it, leave, and re-enter the polygon.
However convex polygons do not allow this, and hence the property.

 

\section {Star-Shaped Polygons}

\section {Inverse Range-Queries}

\end{document}
