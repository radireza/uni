%The function which measures the cost of invoking actor #1 on processor #2.
\newcommand{\invoke}[2]{Inv(#1, #2)}
%The function which measures the cost of communication between actor #1 if it is on processor #3 and actor #2 if it is on processor #4
\newcommand{\commu}[4]{Com(#1, #2, #3, #4)}

%The predicate determining whether nodes #2 and #3 are connected in the graph #1.
\newcommand{\path}[3]{\pi_{#1}(#2, #3)}
%The negation of the path predicate $\path{#1}{#2}{#3}$.
\newcommand{\npath}[3]{\neg\path{#1}{#2}{#3}}

%An Instance of the MTC problem.
\newcommand{\mInstance}{I}
%An Instance of the RAAP problem mapped from the MTC problem.
\newcommand{\rInstance}{I'}

%A solution to the MTC problem.
\newcommand{\mSolution}{S}
%The function for determining the cost of a solution to the MTC problem.
\newcommand{\mCost}{C}
%The feasible solution space for the MTC problem.
\newcommand{\mFeasible}{F}
%The optimal solution space for the MTC problem.
\newcommand{\mOptimal}{O}

%A solution to the RAAP problem.
\newcommand{\rSolution}{\alpha}
%The function for determining the cost of a solution to the RAAP problem.
\newcommand{\rCost}{C'}
%The feasible solution space for the RAAP problem.
\newcommand{\rFeasible}{F'}
%The optimal solution space for the RAAP problem.
\newcommand{\rOptimal}{O'}

%The function for retreiving the solution for the MTC problem from its mapped RAAP version's solution.
\newcommand{\reverse}{\gamma}
%The function for inserting the solution to an MTC problem into its mapped RAAP version's solution.
\newcommand{\inverse}{\gamma'}
